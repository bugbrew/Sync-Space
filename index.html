<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SyncSpace Pro - Collaborative Whiteboard</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background: #eee;
        }

        canvas {
            display: block;
            background: white;
            cursor: crosshair;
        }

        .toolbar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 10px 20px;
            border-radius: 50px;
            display: flex;
            gap: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            align-items: center;
            z-index: 1000;
        }

        .color-circle {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .color-circle.active {
            border-color: #000;
        }

        .tool-btn {
            padding: 5px 15px;
            cursor: pointer;
            border-radius: 20px;
            border: 1px solid #ddd;
            background: #fff;
        }

        .tool-btn.active {
            background: #000;
            color: #fff;
        }

        .cursor {
            position: fixed;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            transition: left 0.1s linear, top 0.1s linear;
        }

        .cursor-label {
            position: absolute;
            top: 15px;
            left: 10px;
            background: #333;
            color: white;
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            white-space: nowrap;
        }
    </style>
</head>

<body>

    <div class="toolbar">
        <div class="color-circle active" style="background: #000000;" onclick="setColor('#000000', this)"></div>
        <div class="color-circle" style="background: #ff4757;" onclick="setColor('#ff4757', this)"></div>
        <div class="color-circle" style="background: #2ed573;" onclick="setColor('#2ed573', this)"></div>
        <div class="color-circle" style="background: #1e90ff;" onclick="setColor('#1e90ff', this)"></div>
        <button class="tool-btn" id="eraserBtn" onclick="setEraser()">Eraser</button>
        <button class="tool-btn" onclick="clearCanvas()">Clear All</button>
    </div>

    <canvas id="whiteboard"></canvas>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <script>
        // 1. UI & CANVAS INITIALIZATION
        const myName = prompt("Enter your name to join SyncSpace:") || "Guest";
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');

        // Ensure canvas matches window size exactly
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let drawing = false;
        let currentTool = 'pencil';
        let currentColor = '#000000';
        let lastPos = { x: 0, y: 0 };

        // 2. CORE DRAWING FUNCTION
        function drawLine(x0, y0, x1, y1, color, width, emit) {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.closePath();

            if (!emit) return; // Important: Don't re-emit if drawing history/others' lines
            socket.emit('drawing_data', { x0, y0, x1, y1, color, width });
        }

        // 3. CONNECT TO BACKEND
        const socket = io("https://sync-space.onrender.com");

        // 4. SOCKET LISTENERS (Setup before doing any emitting)
        socket.on('connect', () => {
            console.log("Connected to server! ID:", socket.id);
            socket.emit('join_workspace', myName);
        });

        // This is the specific fix for the "Third Window" issue
        socket.on('drawing_history', (history) => {
            console.log("ðŸ“¦ History Received from DB:", history.length, "strokes");
            history.forEach(stroke => {
                drawLine(stroke.x0, stroke.y0, stroke.x1, stroke.y1, stroke.color, stroke.width, false);
            });
        });

        socket.on('receive_drawing', (data) => {
            drawLine(data.x0, data.y0, data.x1, data.y1, data.color, data.width, false);
        });

        socket.on('clear_board_ui', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        socket.on('receive_cursor', (data) => {
            let el = document.getElementById(data.id);
            if (!el) {
                el = document.createElement('div');
                el.id = data.id;
                el.className = 'cursor';
                el.style.backgroundColor = `hsl(${Math.random() * 360}, 70%, 50%)`;
                const label = document.createElement('div');
                label.className = 'cursor-label';
                el.appendChild(label);
                document.body.appendChild(el);
            }
            el.querySelector('.cursor-label').innerText = data.username;
            el.style.left = data.x + 'px';
            el.style.top = data.y + 'px';
        });

        socket.on('user_disconnected', (id) => {
            const el = document.getElementById(id);
            if (el) el.remove();
        });

        // 5. TOOLBAR & MOUSE EVENTS
        function setColor(color, el) {
            currentColor = color;
            currentTool = 'pencil';
            document.querySelectorAll('.color-circle, .tool-btn').forEach(b => b.classList.remove('active'));
            el.classList.add('active');
        }

        function setEraser() {
            currentTool = 'eraser';
            document.querySelectorAll('.color-circle, .tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('eraserBtn').classList.add('active');
        }

        function clearCanvas() {
            if (confirm("Clear board for everyone?")) {
                socket.emit('clear_board');
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            drawing = true;
            lastPos = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mouseup', () => drawing = false);

        canvas.addEventListener('mousemove', (e) => {
            // Update cursor position for others
            socket.emit('cursor_move', { x: e.clientX, y: e.clientY });

            if (!drawing) return;

            const width = (currentTool === 'eraser') ? 40 : 3;
            const color = (currentTool === 'eraser') ? '#ffffff' : currentColor;

            drawLine(lastPos.x, lastPos.y, e.clientX, e.clientY, color, width, true);
            lastPos = { x: e.clientX, y: e.clientY };
        });

        // Handle window resizing to prevent drawing loss
        window.addEventListener('resize', () => {
            // Optional: You could save canvas data here, resize, then redraw
            // For now, we just ensure the internal width matches the screen
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Ask for history again if resize clears the canvas
            socket.emit('request_history');
        });
    </script>
</body>

</html>